---
layout: post
title: "解决java CPU100%的问题"
date: 2014-09-27T23:30:00-08:00
categories :
  -- arch
  -- it
---
-   一般查找性能瓶颈问题，可以从CPU、DISK IO、内存、SWAP这四处着手。

1 CPU检查

使用指令top

![](</images/2014/cpu100.jpg>)

可以看到PID 62742的**进程**,占用的CPU达73.9，并随之上升至100%以上。如果进一步查看进程的线程，可以在shift+h。或者执行

\``top -h -p 62742`\`

如下

![](</images/2014/cpu100-2.jpg>)

cpu的问题往往都不是CPU的问题，比较绕口，也就是说，绝大多数情况你并不需要升级你的处理器。其往往是由于其它原因造成，下面的例子就是这样的。

2 内存

\``free -m`\`

![](</images/2014/free.png>)

虽然使用了20多G，但是还有3g左右，可忽略

1.  Disk io

\``iostat -c`\`

![](</images/2014/diskio.jpg>)

iowait仅有0.10，很正常，《Web容量规划的艺术》一书中曾经介绍说，其在运维中发现mysql服务的iowait达到46%时网站出行异常，当他经优化将之降至很小后发现网站读取变正常了。可见这里，iowait等各种指标没有办法设定一个准确的值，40%还是10%代表网站出现了问题，但是如果指标出现大幅的变化，这是一个有用的信号。

1.  swap

\``vmsta 1`\`

![](</images/2014/vmstat.jpg>)

si/so分别代表数据从硬盘移入内存/数据从内存移入硬盘，bi/bo是写/读硬盘的数据。我们知道，一般我们设置swap分区，以在数据不需要或者内存资源不够的时候写入swap（硬盘）以节省内存的空间。我们知道这是一个比较好的策略，毕竟内存是比较宝贵的资源，这也是mysql的软件设计时会充分考虑swap分区使用的原因。但是当内存资源严重不足，或者软件设计的原因造成其不断地需要从硬盘交互数据到内存的时候，这会相比直接从内存读取花费非常长的时间。

上述的指标除了cpu以外均是正常的。

 

找出现象背后的真相
=========

上述的几点仅是是现象或者说是结果，我们往往需要找到背后的始作俑者。

比如通过top指令，我们知道一次cpu
100%的java进程PID62742，但是我们不能直接杀掉它。还好我们可以用其它的手段继续分析它。我想说明的是，任何技术总有短板。以下是一个解决CPU100%的例子：

来使用jstack工具查看

\``sudo /usr/java/jdk1.7.0_10/bin/jstack 62742> cpu_100`\`` `

还记得上面监控结果中，进程62742其线程中占用cpu最大的前三位PID分别为62757、62758、62759，转换成16进制分别为0xf525、0xf526、0xf527。然后再cpu\_100的文件中查找

![](</images/2014/cpu100-3.jpg>)

结果中显示上述的三个线程均在GC内存回收。

    >   小技巧

    >   如何转化16进制，使用win7自带的计算器即可，具体地在菜单"查看"中选择程序设计师

现在我们知道是GC造成cpu出现100%，为了处理问题，我们可以加大内存或者优化内存回收算法、以及找到造成GC的代码。

使用jmap查看各种类使用的内存情况

![](</images/2014/jmap.jpg>)

使用eclipse Memory Analyzer([下载][1])进行分析，结果发现两个问题

[1]: <http://51write.github.io/files/MemoryAnalyzer-1.4.0.201406041413.zip>

![](</images/2014/jmap-2.jpg>)

两个问题都与elasticsearch有关，一个流行的检索产品。想起之前为了监控，部署了logstash，其核心点就是使用elasticsearch实现的。由于服务器比较多，我选择比较廉价的方式，将其移走，然后cpu
15分钟后指标就正常了。指标的恢复和其统计的周期有关，哪怕你解决了问题，它也不会马上恢复正常。
